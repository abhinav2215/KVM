#!/usr/bin/perl
# Utility drawer for Appliance.
# $Id: KVM.pm.in,v 1.6 2011/07/07 20:29:55
#
# $Log: KVM,v $
# Revision 1.0  2011/07/07 20:29:55  Abhinav
#package KVM;
require Exporter;
@ISA = qw(Exporter);
@EXPORT_OK =
  qw(&write_log $PATH_TO_APPLIANCE_LOG &fail &success &initialize &search  &addVIRTUALMACHINE &assignPIP &rebootVM &checkUPTIME &enableprivateNET &createnetworkXML &disprivNETWORK &vmCLONE &createBACKUP &createcustomIMAGE &delBACKUP &delcustomIMAGE &vmREVERTSS &vmSNAPSHOT &attachVolume &detachVolume &deallocatePIP &restorecustomIMAGE &restoreSTIMAGE);
#
$debug = 0;    # set to zero to turn off debugging

$PATH_TO_APPLIANCE_LOG = "/var/log/kvmrpc.log";

sub fail    { 0 }
sub success { 1 }

#use strict;
use DBI;
use File::Remote;
use Symbol;
$ENV{'PATH'} = "/bin:/usr/bin:/sbin:/usr/sbin:/bin:/usr/local/bin";

## FUNCTIONS start here .
####################################################################
# write_log($msg): appends a time/date stamp and $msg to the log file.
####################################################################
sub write_log {
    my $msg = $_[0];

    $msg = date_string() . $msg;

    if ( open( LOGFILE, ">> $PATH_TO_APPLIANCE_LOG" ) ) {
        print LOGFILE $msg . "\n";
        close LOGFILE;
    }
    else {
        print("Couldn't open $PATH_TO_APPLIANCE_LOG!!!");
    }

    if ($debug) {
        print $msg. "\n";
    }

}

####################################################################
# date_string: returns a timestamp suitable for log files.
####################################################################
sub date_string {

    # This should be fast -- no shell commands in here.
    # This routine benchmarked at approx .18 ms,
    # so we can run this more than 1000 times/second
    # QF March 31 1998 (code ripped from bunyan --gb)

    my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) =
      localtime(time);

    $mon++;    # Map 0-11 => 1-12

    return sprintf "%s:%s:%s:%s:%s:%s # ",
      $year + 1900,
      $mon < 10  ? "0$mon"  : $mon,
      $mday < 10 ? "0$mday" : $mday,
      $hour < 10 ? "0$hour" : $hour,
      $min < 10  ? "0$min"  : $min,
      $sec < 10  ? "0$sec"  : $sec;
}

####################################################################
# Change: alters a line in a file
# Change($file, $find, $replacewith)
####################################################################
sub Change {
    my $file    = $_[0];
    my $find    = $_[1];
    my $replace = $_[2];
    my $foundit = 0;
    my @infile;
    write_log("Changing [$find] to [$replace] in $file...");
    if ( -f $file ) {
        unless ( -w $file ) {
            write_log(
                "  $file isn't writeable! Can't change [$find] to [$replace]!");
            return fail;
        }
    }
    else {
        write_log("  Can't \"Change\" a file that doesnt exist! [$file]");
        return fail;
    }
    unless ( open( INFILE, "$file" ) ) {
        write_log("  Unable to open $file for reading");
        return fail;
    }
    @infile = <INFILE>;
    close INFILE;
    unless ( open( OUTFILE, "> $file" ) ) {
        write_log("  Unable to truncate $file for writing");
        return fail;
    }
    foreach (@infile) {
        $foundit++ if /$find/;
        s/$find/$replace/;
        print OUTFILE;
    }
    close OUTFILE;
    if ( $foundit == 0 ) {
        write_log("WARNING: Never found [$find] in $file");
    }
    return success;
}

####################################################################
# search: search a line in file
# search($find, $file)
####################################################################
sub search {
    my $find = $_[0];
    my $file = $_[1];
    my @infile;

    write_log("Searching [$find]  in $file...");

    if ( -f $file ) {
    }
    else {
        write_log("  Can't \"Change\" a file that doesnt exist! [$file]");
        return fail;
    }

    unless ( open( INFILE, "$file" ) ) {
        write_log("  Unable to open $file for reading");
        return fail;
    }
    @infile = <INFILE>;
    close INFILE;

    foreach (@in#!/usr/bin/perl
# Utility drawer for Appliance.
# $Id: KVM.pm.in,v 1.6 2011/07/07 20:29:55
#
# $Log: KVM,v $
# Revision 1.0  2011/07/07 20:29:55  Abhinav
#package KVM;
require Exporter;
@ISA = qw(Exporter);
@EXPORT_OK =
  qw(&write_log $PATH_TO_APPLIANCE_LOG &fail &success &initialize &search  &addVIRTUALMACHINE &assignPIP &rebootVM &checkUPTIME &enableprivateNET &createnetworkXML &disprivNETWORK &vmCLONE &createBACKUP &createcustomIMAGE &delBACKUP &delcustomIMAGE &vmREVERTSS &vmSNAPSHOT &attachVolume &detachVolume &deallocatePIP &restorecustomIMAGE &restoreSTIMAGE);
#
$debug = 0;    # set to zero to turn off debugging

$PATH_TO_APPLIANCE_LOG = "/var/log/kvmrpc.log";

sub fail    { 0 }
sub success { 1 }

#use strict;
use DBI;
use File::Remote;
use Symbol;
$ENV{'PATH'} = "/bin:/usr/bin:/sbin:/usr/sbin:/bin:/usr/local/bin";

## FUNCTIONS start here .
####################################################################
# write_log($msg): appends a time/date stamp and $msg to the log file.
####################################################################
sub write_log {
    my $msg = $_[0];

    $msg = date_string() . $msg;

    if ( open( LOGFILE, ">> $PATH_TO_APPLIANCE_LOG" ) ) {
        print LOGFILE $msg . "\n";
        close LOGFILE;
    }
    else {
        print("Couldn't open $PATH_TO_APPLIANCE_LOG!!!");
    }

    if ($debug) {
        print $msg. "\n";
    }

}

####################################################################
# date_string: returns a timestamp suitable for log files.
####################################################################
sub date_string {

    # This should be fast -- no shell commands in here.
    # This routine benchmarked at approx .18 ms,
    # so we can run this more than 1000 times/second
    # QF March 31 1998 (code ripped from bunyan --gb)

    my ( $sec, $min, $hour, $mday, $mon, $year, $wday, $yday, $isdst ) =
      localtime(time);

    $mon++;    # Map 0-11 => 1-12

    return sprintf "%s:%s:%s:%s:%s:%s # ",
      $year + 1900,
      $mon < 10  ? "0$mon"  : $mon,
      $mday < 10 ? "0$mday" : $mday,
      $hour < 10 ? "0$hour" : $hour,
      $min < 10  ? "0$min"  : $min,
      $sec < 10  ? "0$sec"  : $sec;
}

####################################################################
# Change: alters a line in a file
# Change($file, $find, $replacewith)
####################################################################
sub Change {
    my $file    = $_[0];
    my $find    = $_[1];
    my $replace = $_[2];
    my $foundit = 0;
    my @infile;
    write_log("Changing [$find] to [$replace] in $file...");
    if ( -f $file ) {
        unless ( -w $file ) {
            write_log(
                "  $file isn't writeable! Can't change [$find] to [$replace]!");
            return fail;
        }
    }
    else {
        write_log("  Can't \"Change\" a file that doesnt exist! [$file]");
        return fail;
    }
    unless ( open( INFILE, "$file" ) ) {
        write_log("  Unable to open $file for reading");
        return fail;
    }
    @infile = <INFILE>;
    close INFILE;
    unless ( open( OUTFILE, "> $file" ) ) {
        write_log("  Unable to truncate $file for writing");
        return fail;
    }
    foreach (@infile) {
        $foundit++ if /$find/;
        s/$find/$replace/;
        print OUTFILE;
    }
    close OUTFILE;
    if ( $foundit == 0 ) {
        write_log("WARNING: Never found [$find] in $file");
    }
    return success;
}

####################################################################
# search: search a line in file
# search($find, $file)
####################################################################
sub search {
    my $find = $_[0];
    my $file = $_[1];
    my @infile;

    write_log("Searching [$find]  in $file...");

    if ( -f $file ) {
    }
    else {
        write_log("  Can't \"Change\" a file that doesnt exist! [$file]");
        return fail;
    }

    unless ( open( INFILE, "$file" ) ) {
        write_log("  Unable to open $file for reading");
        return fail;
    }
    @infile = <INFILE>;
    close INFILE;

    foreach (@in